/*! For license information please see b24def81.843c903e.js.LICENSE.txt */
"use strict";(self.webpackChunkbackstage_microsite=self.webpackChunkbackstage_microsite||[]).push([[157924],{941041:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>o,contentTitle:()=>i,default:()=>h,frontMatter:()=>s,metadata:()=>c,toc:()=>d});var t=n(785893),a=n(511151);const s={id:"url-reader",title:"Url Reader Service",sidebar_label:"Url Reader",description:"Documentation for the Url Reader service"},i="URL Readers",c={id:"backend-system/core-services/url-reader",title:"Url Reader Service",description:"Documentation for the Url Reader service",source:"@site/../docs/backend-system/core-services/url-reader.md",sourceDirName:"backend-system/core-services",slug:"/backend-system/core-services/url-reader",permalink:"/docs/backend-system/core-services/url-reader",draft:!1,unlisted:!1,editUrl:"https://github.com/backstage/backstage/edit/master/docs/../docs/backend-system/core-services/url-reader.md",tags:[],version:"current",frontMatter:{id:"url-reader",title:"Url Reader Service",sidebar_label:"Url Reader",description:"Documentation for the Url Reader service"},sidebar:"docs",previous:{title:"Token Manager",permalink:"/docs/backend-system/core-services/token-manager"},next:{title:"User Info",permalink:"/docs/backend-system/core-services/user-info"}},o={},d=[{value:"Using the service",id:"using-the-service",level:2},{value:"Providing custom URL readers",id:"providing-custom-url-readers",level:2},{value:"Writing URL Readers",id:"writing-url-readers",level:2},{value:"<code>readUrl</code>",id:"readurl",level:4},{value:"<code>readTree</code>",id:"readtree",level:4},{value:"<code>search</code>",id:"search",level:4},{value:"Caching",id:"caching",level:3}];function l(e){const r={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,a.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(r.header,{children:(0,t.jsx)(r.h1,{id:"url-readers",children:"URL Readers"})}),"\n",(0,t.jsxs)(r.p,{children:["Plugins will require communication with certain integrations that users have configured. Popular integrations are things like Version Control Systems (VSC), such as GitHub, BitBucket GitLab etc. These integrations are configured in the ",(0,t.jsx)(r.code,{children:"integrations"})," section of the ",(0,t.jsx)(r.code,{children:"app-config.yaml"})," file."]}),"\n",(0,t.jsx)(r.p,{children:"These URL readers are basically wrappers with authentication for files and folders that could be stored in these VCS repositories."}),"\n",(0,t.jsx)(r.h2,{id:"using-the-service",children:"Using the service"}),"\n",(0,t.jsxs)(r.p,{children:["The following example shows how to get the URL Reader service in your ",(0,t.jsx)(r.code,{children:"example"})," backend plugin to read a file and a directory from a GitHub repository."]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-ts",children:"import {\n  coreServices,\n  createBackendPlugin,\n} from '@backstage/backend-plugin-api';\nimport os from 'os';\n\ncreateBackendPlugin({\n  pluginId: 'example',\n  register(env) {\n    env.registerInit({\n      deps: {\n        urlReader: coreServices.urlReader,\n      },\n      async init({ urlReader }) {\n        const buffer = await urlReader\n          .read('https://github.com/backstage/backstage/blob/master/README.md')\n          .then(r => r.buffer());\n\n        const tmpDir = os.tmpdir();\n        const directory = await urlReader\n          .readTree(\n            'https://github.com/backstage/backstage/tree/master/packages/backend',\n          )\n          .then(tree => tree.dir({ targetDir: tmpDir }));\n      },\n    });\n  },\n});\n"})}),"\n",(0,t.jsx)(r.h2,{id:"providing-custom-url-readers",children:"Providing custom URL readers"}),"\n",(0,t.jsx)(r.p,{children:"You can also create an internal or bespoke reader and provide it to the backend using a service factory. The following example shows how to create a custom URL reader and provide it to the backend."}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-ts",metastring:'title="packages/backend/src/index.ts"',children:"import { createBackend } from '@backstage/backend-defaults';\nimport {\n  ReaderFactory,\n  urlReaderFactoriesServiceRef,\n} from '@backstage/backend-defaults/urlReader';\nimport {\n  createServiceFactory,\n  UrlReaderService,\n} from '@backstage/backend-plugin-api';\nimport { Config } from '@backstage/config';\n\nclass CustomUrlReader implements UrlReaderService {\n  static factory: ReaderFactory = ({ config, treeResponseFactory }) => {\n    const reader = new CustomUrlReader(config);\n    const predicate = (url: URL) => url.host === 'myCustomDomain';\n    return [{ reader, predicate }];\n  };\n\n  constructor(private readonly config: Config) {}\n  // implementations of read, readTree and search methods skipped for this example\n}\n\nconst customReader = createServiceFactory({\n  service: urlReaderFactoriesServiceRef,\n  deps: {},\n  async factory() {\n    return CustomUrlReader.factory;\n  },\n});\n\nconst backend = createBackend();\n// backend.add() of other plugins and modules excluded\nbackend.add(customReader);\n"})}),"\n",(0,t.jsx)(r.h2,{id:"writing-url-readers",children:"Writing URL Readers"}),"\n",(0,t.jsxs)(r.p,{children:["We want to make sure all URL Readers behave in the same way. Hence if possible,\nall the methods of the ",(0,t.jsx)(r.code,{children:"UrlReaderService"})," interface should be implemented. However it\nis okay to start by implementing just one of them and creating issues for the\nremaining ones."]}),"\n",(0,t.jsxs)(r.p,{children:["You can choose to make new URL Readers open source if the use case is beneficial to other users. Either as its own package or by updating the\n",(0,t.jsxs)(r.a,{href:"https://github.com/backstage/backstage/blob/ce2ca68f07ad3334401d3277b989bf145b728a64/packages/backend-defaults/src/entrypoints/urlReader/lib/UrlReaders.ts#L82-L102",children:[(0,t.jsx)(r.code,{children:"default"})," factory"]}),"\nmethod of URL Readers. It's recommended to create an issue in the Backstage repository to discuss the use case and get feedback before starting the implementation of a new core URL Reader."]}),"\n",(0,t.jsx)(r.p,{children:"Here are some general guidelines for writing URL Readers"}),"\n",(0,t.jsx)(r.h4,{id:"readurl",children:(0,t.jsx)(r.code,{children:"readUrl"})}),"\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.code,{children:"readUrl"})," method expects a user-friendly URL, something which can be copied from\nthe browser naturally when a person is browsing the provider in their browser."]}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:["\u2705 Valid URL :\n",(0,t.jsx)(r.code,{children:"https://github.com/backstage/backstage/blob/master/ADOPTERS.md"})]}),"\n",(0,t.jsxs)(r.li,{children:["\u274c Not a valid URL :\n",(0,t.jsx)(r.code,{children:"https://raw.githubusercontent.com/backstage/backstage/master/ADOPTERS.md"})]}),"\n",(0,t.jsxs)(r.li,{children:["\u274c Not a valid URL : ",(0,t.jsx)(r.code,{children:"https://github.com/backstage/backstage/ADOPTERS.md"})]}),"\n"]}),"\n",(0,t.jsxs)(r.p,{children:["Upon receiving the URL, ",(0,t.jsx)(r.code,{children:"readUrl"})," converts the user-friendly URL into an API URL\nwhich can be used to request the provider's API."]}),"\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.code,{children:"readUrl"})," then makes an authenticated request to the provider API and returns the response containing the file's contents and ",(0,t.jsx)(r.code,{children:"ETag"})," (if the provider supports it)."]}),"\n",(0,t.jsx)(r.h4,{id:"readtree",children:(0,t.jsx)(r.code,{children:"readTree"})}),"\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.code,{children:"readTree"})," method also expects user-friendly URLs similar to ",(0,t.jsx)(r.code,{children:"read"})," but the URL\nshould point to a tree (could be the root of a repository or even a\nsub-directory)."]}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:["\u2705 Valid URL : ",(0,t.jsx)(r.code,{children:"https://github.com/backstage/backstage"})]}),"\n",(0,t.jsxs)(r.li,{children:["\u2705 Valid URL : ",(0,t.jsx)(r.code,{children:"https://github.com/backstage/backstage/blob/master"})]}),"\n",(0,t.jsxs)(r.li,{children:["\u2705 Valid URL : ",(0,t.jsx)(r.code,{children:"https://github.com/backstage/backstage/blob/master/docs"})]}),"\n"]}),"\n",(0,t.jsx)(r.p,{children:"Using the provider's API documentation, find out an API endpoint which can be\nused to download either a zip or a tarball. You can download the entire tree\n(e.g. a repository) and filter out in case the user is expecting only a\nsub-tree. But some APIs are smart enough to accept a path and return only a\nsub-tree in the downloaded archive."}),"\n",(0,t.jsx)(r.h4,{id:"search",children:(0,t.jsx)(r.code,{children:"search"})}),"\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.code,{children:"search"})," method expects a glob pattern of a URL and returns a list of files\nmatching the query."]}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:["\u2705 Valid URL :\n",(0,t.jsx)(r.code,{children:"https://github.com/backstage/backstage/blob/master/**/catalog-info.yaml"})]}),"\n",(0,t.jsxs)(r.li,{children:["\u2705 Valid URL : ",(0,t.jsx)(r.code,{children:"https://github.com/backstage/backstage/blob/master/**/*.md"})]}),"\n",(0,t.jsxs)(r.li,{children:["\u2705 Valid URL :\n",(0,t.jsx)(r.code,{children:"https://github.com/backstage/backstage/blob/master/*/package.json"})]}),"\n",(0,t.jsxs)(r.li,{children:["\u2705 Valid URL : ",(0,t.jsx)(r.code,{children:"https://github.com/backstage/backstage/blob/master/README"})]}),"\n"]}),"\n",(0,t.jsxs)(r.p,{children:["The core logic of ",(0,t.jsx)(r.code,{children:"readTree"})," can be used here to extract all the files inside\nthe tree and return the files matching the pattern in the ",(0,t.jsx)(r.code,{children:"url"}),"."]}),"\n",(0,t.jsx)(r.h3,{id:"caching",children:"Caching"}),"\n",(0,t.jsxs)(r.p,{children:["All of the methods above support ETag based caching. If the method is called\nwithout an ETag, the response contains the ETag of the resource (should ideally\nforward the ETag returned by the provider). If the method is called with an\nETag, it first compares the ETag and returns a ",(0,t.jsx)(r.code,{children:"NotModifiedError"})," in case the\nresource has not been modified. This approach is very similar to the actual\n",(0,t.jsx)(r.a,{href:"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag",children:(0,t.jsx)(r.code,{children:"ETag"})})," and\n",(0,t.jsx)(r.a,{href:"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/If-None-Match",children:(0,t.jsx)(r.code,{children:"If-None-Match"})}),"\nHTTP headers."]})]})}function h(e={}){const{wrapper:r}={...(0,a.a)(),...e.components};return r?(0,t.jsx)(r,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}},675251:(e,r,n)=>{var t=n(667294),a=Symbol.for("react.element"),s=Symbol.for("react.fragment"),i=Object.prototype.hasOwnProperty,c=t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,o={key:!0,ref:!0,__self:!0,__source:!0};function d(e,r,n){var t,s={},d=null,l=null;for(t in void 0!==n&&(d=""+n),void 0!==r.key&&(d=""+r.key),void 0!==r.ref&&(l=r.ref),r)i.call(r,t)&&!o.hasOwnProperty(t)&&(s[t]=r[t]);if(e&&e.defaultProps)for(t in r=e.defaultProps)void 0===s[t]&&(s[t]=r[t]);return{$$typeof:a,type:e,key:d,ref:l,props:s,_owner:c.current}}r.Fragment=s,r.jsx=d,r.jsxs=d},785893:(e,r,n)=>{e.exports=n(675251)},511151:(e,r,n)=>{n.d(r,{Z:()=>c,a:()=>i});var t=n(667294);const a={},s=t.createContext(a);function i(e){const r=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function c(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),t.createElement(s.Provider,{value:r},e.children)}}}]);