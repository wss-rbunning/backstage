/*! For license information please see f0b01076.4ccab8b2.js.LICENSE.txt */
"use strict";(self.webpackChunkbackstage_microsite=self.webpackChunkbackstage_microsite||[]).push([[754389],{408352:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>i,toc:()=>l});var s=n(785893),r=n(511151);const a={id:"references",title:"Entity References",description:"How to express references between entities"},o=void 0,i={id:"features/software-catalog/references",title:"Entity References",description:"How to express references between entities",source:"@site/../docs/features/software-catalog/references.md",sourceDirName:"features/software-catalog",slug:"/features/software-catalog/references",permalink:"/docs/features/software-catalog/references",draft:!1,unlisted:!1,editUrl:"https://github.com/backstage/backstage/edit/master/docs/../docs/features/software-catalog/references.md",tags:[],version:"current",frontMatter:{id:"references",title:"Entity References",description:"How to express references between entities"},sidebar:"docs",previous:{title:"YAML File Format",permalink:"/docs/features/software-catalog/descriptor-format"},next:{title:"Well-known Annotations",permalink:"/docs/features/software-catalog/well-known-annotations"}},c={},l=[{value:"String References",id:"string-references",level:2},{value:"Compound References",id:"compound-references",level:2}];function d(e){const t={a:"a",code:"code",em:"em",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(t.p,{children:["Entities commonly have a need to reference other entities. For example, a\n",(0,s.jsx)(t.a,{href:"/docs/features/software-catalog/descriptor-format#kind-component",children:"Component"})," entity may want to declare who\nits owner is by mentioning a Group or User entity, and a User entity may want to\ndeclare what Group entities it is a member of. This article describes how to\nwrite those references in your yaml entity declaration files."]}),"\n",(0,s.jsxs)(t.p,{children:["Each entity in the catalog is uniquely identified by the triplet of its\n",(0,s.jsx)(t.a,{href:"/docs/features/software-catalog/descriptor-format#apiversion-and-kind-required",children:"kind"}),",\n",(0,s.jsx)(t.a,{href:"/docs/features/software-catalog/descriptor-format#namespace-optional",children:"namespace"}),", and\n",(0,s.jsx)(t.a,{href:"/docs/features/software-catalog/descriptor-format#name-required",children:"name"}),". But that's a lot to type out\nmanually, and in a lot of circumstances, both the kind and the namespace are\nfixed, or possible to deduce, or could have sane default values. So in order to\nhelp the writer, the catalog has a few tricks up its sleeve."]}),"\n",(0,s.jsx)(t.p,{children:"Each reference can be expressed in one of two ways: as a compact string, or as a\ncompound reference structure."}),"\n",(0,s.jsx)(t.h2,{id:"string-references",children:"String References"}),"\n",(0,s.jsx)(t.p,{children:"This is the most common alternative and is used in almost all circumstances."}),"\n",(0,s.jsxs)(t.p,{children:["The string is of the form ",(0,s.jsx)(t.code,{children:"[<kind>:][<namespace>/]<name>"}),". That is, it is\ncomposed of between one and three parts in this specific order, without any\nadditional encoding:"]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"Optionally, the kind, followed by a colon"}),"\n",(0,s.jsx)(t.li,{children:"Optionally, the namespace, followed by a forward slash"}),"\n",(0,s.jsx)(t.li,{children:"The name"}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"The name is always required. Depending on the context, you may be able to leave\nout the kind and/or namespace. If you do, it is contextual what values will be\nused, and the relevant documentation should specify which rule applies where.\nAll strings are case insensitive."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-yaml",children:"# Example:\napiVersion: backstage.io/v1alpha1\nkind: Component\nmetadata:\n  name: petstore\n  namespace: external-systems\n  description: Petstore\nspec:\n  type: service\n  lifecycle: experimental\n  owner: group:pet-managers\n  providesApis:\n    - petstore\n    - internal/streetlights\n    - hello-world\n"})}),"\n",(0,s.jsxs)(t.p,{children:["The field ",(0,s.jsx)(t.code,{children:"spec.owner"})," is a reference. In this case, the string\n",(0,s.jsx)(t.code,{children:"group:pet-managers"})," was given by the user. That means that the kind is ",(0,s.jsx)(t.code,{children:"Group"}),",\nthe namespace is left out, and the name is ",(0,s.jsx)(t.code,{children:"pet-managers"}),". In this context, the\nnamespace was chosen to fall back to the value ",(0,s.jsx)(t.code,{children:"default"})," by the code that parsed\nthe reference, so the end result is that we expect to find another entity in the\ncatalog that is of kind ",(0,s.jsx)(t.code,{children:"Group"}),", namespace ",(0,s.jsx)(t.code,{children:"default"})," (which, actually, also can\nbe left out in its own yaml file because that's the default value there too),\nand name ",(0,s.jsx)(t.code,{children:"pet-managers"}),"."]}),"\n",(0,s.jsxs)(t.p,{children:["The entries in ",(0,s.jsx)(t.code,{children:"providesApis"})," are also references. In this case, none of them\nneeds to specify a kind since we know from the context that that's the only kind\nthat's supported here. The second entry specifies a namespace but the other ones\ndon't, and in this context, the default is to refer to the same namespace as the\noriginating entity (",(0,s.jsx)(t.code,{children:"external-systems"})," here). So the three references\nessentially expand to ",(0,s.jsx)(t.code,{children:"api:external-systems/petstore"}),",\n",(0,s.jsx)(t.code,{children:"api:internal/streetlights"}),", and ",(0,s.jsx)(t.code,{children:"api:external-systems/hello-world"}),". We expect\nthere to exist three API kind entities in the catalog matching those references."]}),"\n",(0,s.jsxs)(t.p,{children:["Note that the remarks above in regards to shortening (leaving out kind and/or\nnamespace) ",(0,s.jsx)(t.em,{children:"only"})," apply for the entity input YAML data. In protocols, storage\nsystems, or when referring to entities externally, the entity ref always\nconsists of all three parts."]}),"\n",(0,s.jsx)(t.h2,{id:"compound-references",children:"Compound References"}),"\n",(0,s.jsx)(t.p,{children:"This is a more verbose version of a reference, where each part of the\nkind-namespace-name triplet is expressed as a field in an object. You may see\nthis structure used in Backstage code, but it should normally not be used in any\nform of protocol or between plugins and/or external systems. For those cases,\ninstead prefer to use the string form which has clearer semantics and can be\ntransported more easily since it's just a string."})]})}function h(e={}){const{wrapper:t}={...(0,r.a)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},675251:(e,t,n)=>{var s=n(667294),r=Symbol.for("react.element"),a=Symbol.for("react.fragment"),o=Object.prototype.hasOwnProperty,i=s.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,c={key:!0,ref:!0,__self:!0,__source:!0};function l(e,t,n){var s,a={},l=null,d=null;for(s in void 0!==n&&(l=""+n),void 0!==t.key&&(l=""+t.key),void 0!==t.ref&&(d=t.ref),t)o.call(t,s)&&!c.hasOwnProperty(s)&&(a[s]=t[s]);if(e&&e.defaultProps)for(s in t=e.defaultProps)void 0===a[s]&&(a[s]=t[s]);return{$$typeof:r,type:e,key:l,ref:d,props:a,_owner:i.current}}t.Fragment=a,t.jsx=l,t.jsxs=l},785893:(e,t,n)=>{e.exports=n(675251)},511151:(e,t,n)=>{n.d(t,{Z:()=>i,a:()=>o});var s=n(667294);const r={},a=s.createContext(r);function o(e){const t=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),s.createElement(a.Provider,{value:t},e.children)}}}]);