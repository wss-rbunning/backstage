/*! For license information please see 5aad9670.53a2713d.js.LICENSE.txt */
"use strict";(self.webpackChunkbackstage_microsite=self.webpackChunkbackstage_microsite||[]).push([[346511],{598136:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>h,frontMatter:()=>o,metadata:()=>a,toc:()=>c});var i=t(785893),r=t(511151);const o={id:"extension-blueprints",title:"Frontend Extension Blueprints",sidebar_label:"Extensions Blueprints",description:"Frontend extensions"},s=void 0,a={id:"frontend-system/architecture/extension-blueprints",title:"Frontend Extension Blueprints",description:"Frontend extensions",source:"@site/../docs/frontend-system/architecture/23-extension-blueprints.md",sourceDirName:"frontend-system/architecture",slug:"/frontend-system/architecture/extension-blueprints",permalink:"/docs/frontend-system/architecture/extension-blueprints",draft:!1,unlisted:!1,editUrl:"https://github.com/backstage/backstage/edit/master/docs/../docs/frontend-system/architecture/23-extension-blueprints.md",tags:[],version:"current",sidebarPosition:23,frontMatter:{id:"extension-blueprints",title:"Frontend Extension Blueprints",sidebar_label:"Extensions Blueprints",description:"Frontend extensions"},sidebar:"docs",previous:{title:"Extensions",permalink:"/docs/frontend-system/architecture/extensions"},next:{title:"Extension Overrides",permalink:"/docs/frontend-system/architecture/extension-overrides"}},l={},c=[{value:"Creating an extension from a blueprint",id:"creating-an-extension-from-a-blueprint",level:2},{value:"Creating an extension from a blueprint with overrides",id:"creating-an-extension-from-a-blueprint-with-overrides",level:2},{value:"Creating an extension blueprint",id:"creating-an-extension-blueprint",level:2},{value:"Blueprint-specific extension data references",id:"blueprint-specific-extension-data-references",level:3},{value:"Extension Blueprints in libraries",id:"extension-blueprints-in-libraries",level:3}];function d(e){const n={a:"a",blockquote:"blockquote",code:"code",h2:"h2",h3:"h3",p:"p",pre:"pre",strong:"strong",...(0,r.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"NOTE: The new frontend system is in alpha and is only supported by a small number of plugins."})}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"createExtension"})," function and related APIs is considered a low-level building and fairly advanced building block, and is not typically what you would use when building plugins and features. Instead, the core APIs and plugins provide extension blueprints that makes it easier to create extensions for specific usages. These blueprints accept a number of parameters that is up to each blueprint to define, and then creates a new extension using the provided parameters. New blueprints are created using the ",(0,i.jsx)(n.code,{children:"createExtensionBlueprint"})," function, and are by convention exported with the symbol ",(0,i.jsx)(n.code,{children:"<Kind>Blueprint"}),". If you are curious about what blueprints are available from a plugin or package, look for ",(0,i.jsx)(n.code,{children:"*Blueprint"})," exports in the package's API, for plugins these are typically found in the ",(0,i.jsx)(n.code,{children:"*-react"})," package."]}),"\n",(0,i.jsx)(n.h2,{id:"creating-an-extension-from-a-blueprint",children:"Creating an extension from a blueprint"}),"\n",(0,i.jsxs)(n.p,{children:["Every extension blueprint provides a ",(0,i.jsx)(n.code,{children:"make"})," method that can be used to create new extensions. It is a simple way to create a new extension where the base blueprint provides all the necessary functionality. All you need to do is to provide the necessary blueprint parameters, but you also have the ability to provide additional options, for example a ",(0,i.jsx)(n.code,{children:"name"})," for the extension."]}),"\n",(0,i.jsxs)(n.p,{children:["The following is a simple example of how one might use the blueprint ",(0,i.jsx)(n.code,{children:"make"})," method to create a new extension:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",children:"const myPageExtension = PageBlueprint.make({\n  params: {\n    defaultPath: '/my-page',\n    loader: () => import('./components/MyPage').them(m => <m.MyPage />),\n  },\n});\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The returned ",(0,i.jsx)(n.code,{children:"myPageExtension"})," is an extension which is ready to be used in a plugin. It is the same type of object as is returned by the lower level ",(0,i.jsx)(n.code,{children:"createExtension"})," function."]}),"\n",(0,i.jsx)(n.h2,{id:"creating-an-extension-from-a-blueprint-with-overrides",children:"Creating an extension from a blueprint with overrides"}),"\n",(0,i.jsxs)(n.p,{children:["Every extension blueprint also provides a ",(0,i.jsx)(n.code,{children:"makeWithOverrides"})," method. It is useful in cases where you want to provide additional integration points for an extension created with a blueprint. You might for example want to define additional inputs or configuration schema, or use the existing configuration to dynamically compute the parameters passed to the blueprint."]}),"\n",(0,i.jsxs)(n.p,{children:["The following is an example of how one might use the blueprint ",(0,i.jsx)(n.code,{children:"makeWithOverrides"})," method to create a new extension:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",children:"const myPageExtension = PageBlueprint.makeWithOverrides({\n  config: {\n    schema: {\n      layout: z => z.enum(['grid', 'rows']).default('grid'),\n    },\n  },\n  // The original blueprint factory is provided as the first argument\n  factory(originalFactory, { config }) {\n    // Call and forward the result from the original factory, providing\n    // the blueprint parameters as the first argument.\n    return originalFactory({\n      defaultPath: '/my-page',\n      loader: () =>\n        import('./components/MyPage').them(m => (\n          // We can now access values from the factory context when providing\n          // the blueprint parameters, such as config values.\n          <m.MyPage layout={config.layout} />\n        )),\n    });\n  },\n});\n"})}),"\n",(0,i.jsxs)(n.p,{children:["When using ",(0,i.jsx)(n.code,{children:"makeWithOverrides"}),", we no longer pass the blueprint parameters directly. Instead, we provide a ",(0,i.jsx)(n.code,{children:"factory"})," function that receives the original blueprint factory as the first argument, and the extension factory context as the second. We can then call the original blueprint factory with the blueprint parameters and forward the result as the return value of out factory. Notice that when passing the blueprint parameters using this pattern we have access to a lot more information than when using the ",(0,i.jsx)(n.code,{children:"make"})," method, at the cost of being more complex."]}),"\n",(0,i.jsxs)(n.p,{children:["Apart from the addition of the blueprint parameters of the first argument to the original factory function, the ",(0,i.jsx)(n.code,{children:"makeWithOverrides"})," method works the same way as ",(0,i.jsx)(n.a,{href:"/docs/frontend-system/architecture/extension-overrides",children:"extension overrides"}),". All the same options and rules apply, including the ability to define additional inputs, override outputs, and so on. We therefore defer to the ",(0,i.jsx)(n.a,{href:"/docs/frontend-system/architecture/extension-overrides",children:"extension overrides"})," documentation for more information on how to use the ",(0,i.jsx)(n.code,{children:"makeWithOverrides"})," method."]}),"\n",(0,i.jsx)(n.h2,{id:"creating-an-extension-blueprint",children:"Creating an extension blueprint"}),"\n",(0,i.jsxs)(n.p,{children:["To create a new extension blueprint, you use the ",(0,i.jsx)(n.code,{children:"createExtensionBlueprint"})," function. At the surface it is very similar to ",(0,i.jsx)(n.code,{children:"createExtension"}),", but with a few key differences. Firstly you must provide a ",(0,i.jsx)(n.code,{children:"kind"})," option, which will be the kind of all extensions created with the blueprint. See the ",(0,i.jsx)(n.a,{href:"/docs/frontend-system/architecture/naming-patterns",children:"naming patterns section"})," for more information about how to select a good extension kind. Secondly, the ",(0,i.jsx)(n.code,{children:"factory"})," function has a new signature where the first parameter is the blueprint parameters, and the second is the factory context. And finally, rather than returning an extension, ",(0,i.jsx)(n.code,{children:"createExtensionBlueprint"})," returns a blueprint object with the ",(0,i.jsx)(n.code,{children:"make"})," method and friends, which is used as is described above."]}),"\n",(0,i.jsx)(n.p,{children:"The following is an example of how one might create a new extension blueprint:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",children:"export interface MyWidgetBlueprintParams {\n  defaultTitle: string;\n  element: JSX.Element;\n}\n\nexport const MyWidgetBlueprint = createExtensionBlueprint({\n  kind: 'my-widget',\n  attachTo: { id: 'page:my-plugin', input: 'widgets' },\n  config: {\n    schema: {\n      title: z.string().optional(),\n    },\n  },\n  output: [coreExtensionData.reactElement],\n  factory(params: MyWidgetBlueprintParams, { config }) {\n    return [\n      // Note that while this is a valid pattern, you might often want to\n      // return separate pieces of data instead, more on that below.\n      coreExtensionData.reactElement(\n        <MyWidgetContainer title={config.title ?? params.defaultTitle}>\n          {params.element}\n        </MyWidgetContainer>,\n      ),\n    ];\n  },\n});\n"})}),"\n",(0,i.jsx)(n.p,{children:"This is of course a quite bare-bones example blueprint, but still a very real example. Blueprints can be very simple, there's already a lot of value in encapsulating the extension kind, attachment point, and output in a blueprint."}),"\n",(0,i.jsxs)(n.p,{children:["Most of the options provided to ",(0,i.jsx)(n.code,{children:"createExtensionBlueprint"})," can be overridden when using ",(0,i.jsx)(n.code,{children:"makeWithOverrides"})," to create an extension from the blueprint. These overrides work the same way as ",(0,i.jsx)(n.a,{href:"/docs/frontend-system/architecture/extension-overrides",children:"extension overrides"}),", and we defer to that documentation for more information on how overrides work."]}),"\n",(0,i.jsx)(n.h3,{id:"blueprint-specific-extension-data-references",children:"Blueprint-specific extension data references"}),"\n",(0,i.jsxs)(n.p,{children:["In some cases you may want to define and provide ",(0,i.jsx)(n.a,{href:"/docs/frontend-system/architecture/extensions#extension-data-references",children:"extension data reference"})," that are specific to your blueprint. In the above example we might want to forward the ",(0,i.jsx)(n.code,{children:"title"})," as data for example, rather than encapsulating it into the ",(0,i.jsx)(n.code,{children:"MyWidgetContainer"})," component. This gives the parent extension more flexibility in the rendering for our example widget extensions."]}),"\n",(0,i.jsxs)(n.p,{children:["To do that, we create a new extension data reference for our widget title. This references is provided via the ",(0,i.jsx)(n.code,{children:"dataRefs"})," options when we create the blueprint, which makes it available for use via ",(0,i.jsx)(n.code,{children:"MyWidgetBlueprint.dataRefs.widgetTitle"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",children:"export interface MyWidgetBlueprintParams {\n  defaultTitle: string;\n  element: JSX.Element;\n}\n\nconst widgetTitleRef = createExtensionDataRef<string>().with({\n  id: 'my-plugin.widget.title',\n});\n\nexport const MyWidgetBlueprint = createExtensionBlueprint({\n  kind: 'my-widget',\n  attachTo: { id: 'page:my-plugin', input: 'widgets' },\n  config: {\n    schema: {\n      title: z.string().optional(),\n    },\n  },\n  output: [widgetTitleRef, coreExtensionData.reactElement],\n  factory(params: MyWidgetBlueprintParams, { config }) {\n    return [\n      widgetTitleRef(config.title ?? params.defaultTitle),\n      coreExtensionData.reactElement(params.element),\n    ];\n  },\n  dataRefs: {\n    widgetTitle: widgetTitleRef,\n  },\n});\n"})}),"\n",(0,i.jsx)(n.h3,{id:"extension-blueprints-in-libraries",children:"Extension Blueprints in libraries"}),"\n",(0,i.jsxs)(n.p,{children:["If you are publishing a plugin, the extension creators should always be exported from frontend library packages (e.g. ",(0,i.jsx)(n.code,{children:"*-react"}),") rather than plugin packages."]})]})}function h(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},675251:(e,n,t)=>{var i=t(667294),r=Symbol.for("react.element"),o=Symbol.for("react.fragment"),s=Object.prototype.hasOwnProperty,a=i.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,l={key:!0,ref:!0,__self:!0,__source:!0};function c(e,n,t){var i,o={},c=null,d=null;for(i in void 0!==t&&(c=""+t),void 0!==n.key&&(c=""+n.key),void 0!==n.ref&&(d=n.ref),n)s.call(n,i)&&!l.hasOwnProperty(i)&&(o[i]=n[i]);if(e&&e.defaultProps)for(i in n=e.defaultProps)void 0===o[i]&&(o[i]=n[i]);return{$$typeof:r,type:e,key:c,ref:d,props:o,_owner:a.current}}n.Fragment=o,n.jsx=c,n.jsxs=c},785893:(e,n,t)=>{e.exports=t(675251)},511151:(e,n,t)=>{t.d(n,{Z:()=>a,a:()=>s});var i=t(667294);const r={},o=i.createContext(r);function s(e){const n=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);