/*! For license information please see 949a5102.ca2d7392.js.LICENSE.txt */
"use strict";(self.webpackChunkbackstage_microsite=self.webpackChunkbackstage_microsite||[]).push([[712633],{240946:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>r,metadata:()=>a,toc:()=>c});var i=t(785893),s=t(511151);const r={id:"identity-resolver--old",title:"Sign-in Identities and Resolvers (Old Backend System)",description:"An introduction to Backstage user identities and sign-in resolvers in the old backend system"},o=void 0,a={id:"auth/identity-resolver--old",title:"Sign-in Identities and Resolvers (Old Backend System)",description:"An introduction to Backstage user identities and sign-in resolvers in the old backend system",source:"@site/../docs/auth/identity-resolver--old.md",sourceDirName:"auth",slug:"/auth/identity-resolver--old",permalink:"/docs/auth/identity-resolver--old",draft:!1,unlisted:!1,editUrl:"https://github.com/backstage/backstage/edit/master/docs/../docs/auth/identity-resolver--old.md",tags:[],version:"current",frontMatter:{id:"identity-resolver--old",title:"Sign-in Identities and Resolvers (Old Backend System)",description:"An introduction to Backstage user identities and sign-in resolvers in the old backend system"}},l={},c=[{value:"Quick Start",id:"quick-start",level:2},{value:"Backstage User Identity",id:"backstage-user-identity",level:2},{value:"Sign-in Resolvers",id:"sign-in-resolvers",level:2},{value:"Custom Resolver Example",id:"custom-resolver-example",level:3},{value:"Built-in Resolvers",id:"built-in-resolvers",level:3},{value:"Custom Ownership Resolution",id:"custom-ownership-resolution",level:2},{value:"Sign-In without Users in the Catalog",id:"sign-in-without-users-in-the-catalog",level:2},{value:"AuthHandler",id:"authhandler",level:2}];function h(e){const n={a:"a",admonition:"admonition",blockquote:"blockquote",code:"code",h2:"h2",h3:"h3",p:"p",pre:"pre",...(0,s.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.admonition,{type:"info",children:(0,i.jsxs)(n.p,{children:["This documentation is written for the old backend which has been replaced by\n",(0,i.jsx)(n.a,{href:"/docs/backend-system/",children:"the new backend system"}),", being the default since\nBackstage ",(0,i.jsx)(n.a,{href:"/docs/releases/v1.24.0",children:"version 1.24"}),". If have migrated to the new\nbackend system, you may want to read ",(0,i.jsx)(n.a,{href:"/docs/auth/identity-resolver",children:"its own article"}),"\ninstead. Otherwise, ",(0,i.jsx)(n.a,{href:"/docs/backend-system/building-backends/migrating",children:"consider migrating"}),"!"]})}),"\n",(0,i.jsx)(n.p,{children:"By default, every Backstage auth provider is configured only for the use-case of\naccess delegation. This enables Backstage to request resources and actions from\nexternal systems on behalf of the user, for example re-triggering a build in CI."}),"\n",(0,i.jsx)(n.p,{children:"If you want to use an auth provider to sign in users, you need to explicitly configure\nit have sign-in enabled and also tell it how the external identities should\nbe mapped to user identities within Backstage."}),"\n",(0,i.jsx)(n.h2,{id:"quick-start",children:"Quick Start"}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:["See ",(0,i.jsx)(n.a,{href:"/docs/reference/plugin-auth-backend.providers",children:"providers"}),"\nfor a full list of auth providers and their built-in sign-in resolvers."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["Backstage projects created with ",(0,i.jsx)(n.code,{children:"npx @backstage/create-app"}),' come configured with a\nsign-in resolver for GitHub guest access. This resolver makes all users share\na single "guest" identity and is only intended as a minimum requirement to quickly\nget up and running. You can replace ',(0,i.jsx)(n.code,{children:"github"})," for any of the other providers if you need."]}),"\n",(0,i.jsx)(n.p,{children:"This resolver should not be used in production, as it uses a single shared identity,\nand has no restrictions on who is able to sign-in. Be sure to read through the rest\nof this page to understand the Backstage identity system once you need to install\na resolver for your production environment."}),"\n",(0,i.jsx)(n.p,{children:"The guest resolver can be useful for testing purposes too, and it looks like this:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"signIn: {\n  resolver(_, ctx) {\n    const userRef = 'user:default/guest'\n    return ctx.issueToken({\n      claims: {\n        sub: userRef,\n        ent: [userRef],\n      },\n    }),\n  },\n},\n"})}),"\n",(0,i.jsx)(n.h2,{id:"backstage-user-identity",children:"Backstage User Identity"}),"\n",(0,i.jsxs)(n.p,{children:["A user identity within Backstage is built up from two pieces of information, a\nuser ",(0,i.jsx)(n.a,{href:"/docs/features/software-catalog/references",children:"entity reference"}),", and a\nset of ownership entity references.\nWhen a user signs in, a Backstage token is generated with these two pieces of information,\nwhich is then used to identify the user within the Backstage ecosystem."]}),"\n",(0,i.jsx)(n.p,{children:"The user entity reference should uniquely identify the logged in user in Backstage.\nIt is encouraged that a matching user entity also exists within the Software Catalog,\nbut it is not required. If the user entity exists in the catalog it can be used to\nstore additional data about the user. There may even be some plugins that require\nthis for them to be able to function."}),"\n",(0,i.jsxs)(n.p,{children:["The ownership references are also entity references, and it is likewise\nencouraged that these entities exist within the catalog, but it is not a requirement.\nThe ownership references are used to determine what the user owns, as a set\nof references that the user claims ownership though. For example, a user\nJane (",(0,i.jsx)(n.code,{children:"user:default/jane"}),") might have the ownership references ",(0,i.jsx)(n.code,{children:"user:default/jane"}),",\n",(0,i.jsx)(n.code,{children:"group:default/team-a"}),", and ",(0,i.jsx)(n.code,{children:"group:default/admins"}),". Given these ownership claims,\nany entity that is marked as owned by either of ",(0,i.jsx)(n.code,{children:"user:jane"}),", ",(0,i.jsx)(n.code,{children:"team-a"}),", or ",(0,i.jsx)(n.code,{children:"admins"})," would\nbe considered owned by Jane."]}),"\n",(0,i.jsxs)(n.p,{children:["The ownership claims often contain the user entity reference itself, but it is not\nrequired. It is also worth noting that the ownership claims can also be used to\nresolve other relations similar to ownership, such as a claim for a ",(0,i.jsx)(n.code,{children:"maintainer"})," or\n",(0,i.jsx)(n.code,{children:"operator"})," status."]}),"\n",(0,i.jsxs)(n.p,{children:["The Backstage token that encapsulates the user identity is a JWT. The user entity\nreference is stored in the ",(0,i.jsx)(n.code,{children:"sub"})," claim of the payload, while the ownership references\nare stored in a custom ",(0,i.jsx)(n.code,{children:"ent"})," claim. Both the user and ownership references should\nalways be full entity references, as opposed to shorthands like just ",(0,i.jsx)(n.code,{children:"jane"})," or ",(0,i.jsx)(n.code,{children:"user:jane"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"sign-in-resolvers",children:"Sign-in Resolvers"}),"\n",(0,i.jsx)(n.p,{children:"Signing in a user into Backstage requires a mapping of the user identity from the\nthird-party auth provider to a Backstage user identity. This mapping can vary quite\na lot between different organizations and auth providers, and because of that there's\nno default way to resolve user identities. The auth provider that one wants to use\nfor sign-in must instead be configured with a sign-in resolver, which is a function\nthat is responsible for creating this user identity mapping."}),"\n",(0,i.jsx)(n.p,{children:"The input to the sign-in resolver function is the result of a successful log in with\nthe given auth provider, as well as a context object that contains various helpers\nfor looking up users and issuing tokens. There are also a number of built-in sign-in\nresolvers that can be used, which are covered a bit further down."}),"\n",(0,i.jsx)(n.p,{children:"Note that while it possible to configure multiple auth providers to be used for sign-in,\nyou should take care when doing so. It is best to make sure that the different auth\nproviders either do not have any user overlap, or that any users that are able to log\nin with multiple providers always end up with the same Backstage identity."}),"\n",(0,i.jsx)(n.h3,{id:"custom-resolver-example",children:"Custom Resolver Example"}),"\n",(0,i.jsxs)(n.p,{children:["Let's look at an example of a custom sign-in resolver for the Google auth provider.\nThis all typically happens within your ",(0,i.jsx)(n.code,{children:"packages/backend/src/plugins/auth.ts"})," file,\nwhich is responsible for setting up and configuring the auth backend plugin."]}),"\n",(0,i.jsxs)(n.p,{children:["You provide the resolver as part of the options you pass when creating a new auth\nprovider factory. This means you need to replace the default Google provider with\none that you create. Be sure to also include the existing ",(0,i.jsx)(n.code,{children:"defaultAuthProviderFactories"}),"\nif you want to keep all of the built-in auth providers installed."]}),"\n",(0,i.jsx)(n.p,{children:"Now let's look at the example, with the rest of the commentary being made with in\nthe code comments:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"// File: packages/backend/src/plugins/auth.ts\nimport {\n  createRouter,\n  providers,\n  defaultAuthProviderFactories,\n} from '@backstage/plugin-auth-backend';\nimport { Router } from 'express';\nimport { PluginEnvironment } from '../types';\n\nexport default async function createPlugin(\n  env: PluginEnvironment,\n): Promise<Router> {\n  return await createRouter({\n    ...env,\n    providerFactories: {\n      ...defaultAuthProviderFactories,\n      google: providers.google.create({\n        signIn: {\n          resolver: async (info, ctx) => {\n            const {\n              profile: { email },\n            } = info;\n            // Profiles are not always guaranteed to to have an email address.\n            // You can also find more provider-specific information in `info.result`.\n            // It typically contains a `fullProfile` object as well as ID and/or access\n            // tokens that you can use for additional lookups.\n            if (!email) {\n              throw new Error('User profile contained no email');\n            }\n\n            // You can add your own custom validation logic here.\n            // Logins can be prevented by throwing an error like the one above.\n            myEmailValidator(email);\n\n            // This example resolver simply uses the local part of the email as the name.\n            const [name] = email.split('@');\n\n            // This helper function handles sign-in by looking up a user in the catalog.\n            // The lookup can be done either by reference, annotations, or custom filters.\n            //\n            // The helper also issues a token for the user, using the standard group\n            // membership logic to determine the ownership references of the user.\n            return ctx.signInWithCatalogUser({\n              entityRef: { name },\n            });\n          },\n        },\n      }),\n    },\n  });\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"built-in-resolvers",children:"Built-in Resolvers"}),"\n",(0,i.jsxs)(n.p,{children:["You don't always have to write your own custom resolver. The auth backend plugin provides\nbuilt-in resolvers for many of the common sign-in patterns. You access these via the ",(0,i.jsx)(n.code,{children:"resolvers"}),"\nproperty of each of the auth provider integrations. For example, the Google provider has\na built in resolver that works just like the one we defined above:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"// File: packages/backend/src/plugins/auth.ts\nexport default async function createPlugin(\n  // ...\n  return await createRouter({\n    // ...\n    providerFactories: {\n      // ...\n      google: providers.google.create({\n        signIn: {\n          resolver: providers.google.resolvers.emailLocalPartMatchingUserEntityName(),\n        },\n      });\n    }\n  })\n)\n"})}),"\n",(0,i.jsxs)(n.p,{children:["There are also other options, like the this one that looks up a user\nby matching the ",(0,i.jsx)(n.code,{children:"google.com/email"})," annotation of user entities in the catalog:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"providers.google.create({\n  signIn: {\n    resolver: providers.google.resolvers.emailMatchingUserEntityAnnotation(),\n  },\n});\n"})}),"\n",(0,i.jsx)(n.h2,{id:"custom-ownership-resolution",children:"Custom Ownership Resolution"}),"\n",(0,i.jsxs)(n.p,{children:["If you want to have more control over the membership resolution and token generation\nthat happens during sign-in you can replace ",(0,i.jsx)(n.code,{children:"ctx.signInWithCatalogUser"})," with a set\nof lower-level calls:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"// File: packages/backend/src/plugins/auth.ts\nimport { getDefaultOwnershipEntityRefs } from '@backstage/plugin-auth-backend';\n\nexport default async function createPlugin(\n  // ...\n  return await createRouter({\n    // ...\n    providerFactories: {\n      // ...\n      google: async ({ profile: { email } }, ctx) => {\n        if (!email) {\n          throw new Error('User profile contained no email');\n        }\n\n        // This step calls the catalog to look up a user entity. You could for example\n        // replace it with a call to a different external system.\n        const { entity } = await ctx.findCatalogUser({\n          annotations: {\n            'acme.org/email': email,\n          },\n        });\n\n        // In this step we extract the ownership references from the user entity using\n        // the standard logic. It uses a reference to the entity itself, as well as the\n        // target of each `memberOf` relation where the target is of the kind `Group`.\n        //\n        // If you replace the catalog lookup with something that does not return\n        // an entity you will need to replace this step as well.\n        //\n        // You might also replace it if you for example want to filter out certain groups.\n        //\n        // Note that `getDefaultOwnershipEntityRefs` only includes groups to which the\n        // user has a direct MEMBER_OF relationship. It's perfectly fine to include\n        // groups that the user is transitively part of in the claims array, but the\n        // catalog doesn't currently provide a direct way of accessing this list of\n        // groups.\n        const ownershipRefs = getDefaultOwnershipEntityRefs(entity);\n\n        // The last step is to issue the token, where we might provide more options in the future.\n        return ctx.issueToken({\n          claims: {\n            sub: stringifyEntityRef(entity),\n            ent: ownershipRefs,\n          },\n        });\n      };\n    }\n  })\n)\n"})}),"\n",(0,i.jsx)(n.h2,{id:"sign-in-without-users-in-the-catalog",children:"Sign-In without Users in the Catalog"}),"\n",(0,i.jsx)(n.p,{children:"While populating the catalog with organizational data unlocks more powerful ways\nto browse your software ecosystem, it might not always be a viable or prioritized\noption. However, even if you do not have user entities populated in your catalog, you\ncan still sign in users. As there are currently no built-in sign-in resolvers for\nthis scenario you will need to implement your own."}),"\n",(0,i.jsx)(n.p,{children:"Signing in a user that doesn't exist in the catalog is as simple as skipping the\ncatalog lookup step from the above example. Rather than looking up the user, we\ninstead immediately issue a token using whatever information is available. One caveat\nis that it can be tricky to determine the ownership references, although it can\nbe achieved for example through a lookup to an external service. You typically\nwant to at least use the user itself as a lone ownership reference."}),"\n",(0,i.jsx)(n.p,{children:"Because we no longer use the catalog as an allow-list of users, it is often important\nthat you limit what users are allowed to sign in. This could be a simple email domain\ncheck like in the example below, or you might for example look up the GitHub organizations\nthat the user belongs to using the user access token in the provided result object."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"// File: packages/backend/src/plugins/auth.ts\nimport { createRouter, providers } from '@backstage/plugin-auth-backend';\nimport { Router } from 'express';\nimport { PluginEnvironment } from '../types';\nimport {\n  stringifyEntityRef,\n  DEFAULT_NAMESPACE,\n} from '@backstage/catalog-model';\n\nexport default async function createPlugin(\n  env: PluginEnvironment,\n): Promise<Router> {\n  return await createRouter({\n    ...env,\n    providerFactories: {\n      google: providers.google.create({\n        signIn: {\n          resolver: async ({ profile }, ctx) => {\n            if (!profile.email) {\n              throw new Error(\n                'Login failed, user profile does not contain an email',\n              );\n            }\n            // Split the email into the local part and the domain.\n            const [localPart, domain] = profile.email.split('@');\n\n            // Next we verify the email domain. It is recommended to include this\n            // kind of check if you don't look up the user in an external service.\n            if (domain !== 'acme.org') {\n              throw new Error(\n                `Login failed, this email ${profile.email} does not belong to the expected domain`,\n              );\n            }\n\n            // By using `stringifyEntityRef` we ensure that the reference is formatted correctly\n            const userEntity = stringifyEntityRef({\n              kind: 'User',\n              name: localPart,\n              namespace: DEFAULT_NAMESPACE,\n            });\n            return ctx.issueToken({\n              claims: {\n                sub: userEntity,\n                ent: [userEntity],\n              },\n            });\n          },\n        },\n      }),\n    },\n  });\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"authhandler",children:"AuthHandler"}),"\n",(0,i.jsx)(n.p,{children:"Similar to a custom sign-in resolver, you can also write a custom auth handler\nfunction which is used to verify and convert the auth response into the profile\nthat will be presented to the user. This is where you can customize things like\ndisplay name and profile picture."}),"\n",(0,i.jsx)(n.p,{children:"This is also the place where you can do authorization and validation of the user\nand throw errors if the user should not be allowed access in Backstage."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"// File: packages/backend/src/plugins/auth.ts\nexport default async function createPlugin(\n  env: PluginEnvironment,\n): Promise<Router> {\n  return await createRouter({\n    ...\n    providerFactories: {\n      google: providers.google.create({\n        authHandler: async ({\n          fullProfile  // Type: passport.Profile,\n          idToken      // Type: (Optional) string,\n        }) => {\n          // Custom validation code goes here\n          return {\n            profile: {\n              email,\n              picture,\n              displayName,\n            }\n          };\n        }\n      })\n    }\n  })\n}\n"})})]})}function u(e={}){const{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},675251:(e,n,t)=>{var i=t(667294),s=Symbol.for("react.element"),r=Symbol.for("react.fragment"),o=Object.prototype.hasOwnProperty,a=i.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,l={key:!0,ref:!0,__self:!0,__source:!0};function c(e,n,t){var i,r={},c=null,h=null;for(i in void 0!==t&&(c=""+t),void 0!==n.key&&(c=""+n.key),void 0!==n.ref&&(h=n.ref),n)o.call(n,i)&&!l.hasOwnProperty(i)&&(r[i]=n[i]);if(e&&e.defaultProps)for(i in n=e.defaultProps)void 0===r[i]&&(r[i]=n[i]);return{$$typeof:s,type:e,key:c,ref:h,props:r,_owner:a.current}}n.Fragment=r,n.jsx=c,n.jsxs=c},785893:(e,n,t)=>{e.exports=t(675251)},511151:(e,n,t)=>{t.d(n,{Z:()=>a,a:()=>o});var i=t(667294);const s={},r=i.createContext(s);function o(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);